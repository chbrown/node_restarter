#!/usr/bin/env node
// argv[0] is 'node', argv[1] is the node_restarter path, and [2] is the name of the first command line argument
var fs = require('fs');
var util = require('util');
var events = require('events');
var child_process = require('child_process');
var glob = require('glob');
var minimatch = require('minimatch');

var argv = process.argv;
var argv_split = argv.indexOf('--');
var globs = argv.slice(2, argv_split);
var spawn_args = argv.slice(argv_split + 1);

// usage:
// node_restarter '**/*.js' '**/*.mu' '!node_modules/**/*.js' -- node myapp.js --password yeehaw

// node_restarter takes globs e.g., **/*.js

function FileWatcher(globpaths) {
  events.EventEmitter.call(this);
  var self = this;
  this.watchers = {};

  // preprocess all the globpaths
  var include_globbers = [];
  var exclude_filters = [];
  globpaths.forEach(function(globpath) {
    if (globpath[0] == '!') {
      exclude_filters.push(minimatch.filter(globpath.slice(1)));
    }
    else {
      // console.log('include_globbers+', globpath);
      include_globbers.push(new glob.Glob(globpath));
    }
  });

  var files = {};
  (function next() {
    var globber = include_globbers.shift();
    if (globber) {
      // console.log('>>>', globber.minimatch);
      globber.on('end', function(filenames) {
        for (var f in filenames) {
          var filename = filenames[f];
          // console.log("match", filename);
          // var include = true;
          for (var i in exclude_filters) {
            if (exclude_filters[i](filename)) {
              return;
            }
          }
          self.watch(filename, '');
        }
        next();
      });
      // globber.on('end', next);
    }
    else {
      console.log('finished globbing');
    }
  })();
}
util.inherits(FileWatcher, events.EventEmitter);
FileWatcher.prototype.watch = function(file, globpath) {
  var self = this;
  if (!this.watchers[file]) {
    console.log('starting to watch ', file, globpath);
    this.watchers[file] = fs.watch(file, {persistent: false}, function(event, filename) {
      console.log("Watch triggered:", file);
      self.emit('change', file);
    });
  }
  else {
    console.log(file, 'is already being watched', globpath);
  }
  // else: file is already is being watched
};
FileWatcher.prototype.unwatchAll = function() {
  for (var file in this.watchers) {
    this.watchers[file].close();
    delete this.watchers[file];
  }
};

(function init() {
  var started = Date.now();
  var child = child_process.spawn(spawn_args[0], spawn_args.slice(1));
  console.log('- node_restarter: ' + spawn_args.join(' '));
  child.stdout.pipe(process.stdout, {end: false});
  child.stderr.pipe(process.stderr, {end: false});

  child.on('exit', function (code) {
    setTimeout(init, 1000 - (Date.now() - started));
  });

  process.on('exit', function (code) {
    child.kill();
  });

  var file_watcher = new FileWatcher(globs);
  file_watcher.on('change', function(file) {
    // file_watcher.unwatchAll();
    console.log("Done unwatching");
    child.kill();
  });
})();
